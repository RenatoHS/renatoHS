\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdftitle={Introduction to Parallel Computing},
            pdfauthor={Renato Henriques-Silva},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\newcommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}

  \title{Introduction to Parallel Computing}
    \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
    \author{Renato Henriques-Silva}
    \preauthor{\centering\large\emph}
  \postauthor{\par}
      \predate{\centering\large\emph}
  \postdate{\par}
    \date{November 20, 2018}


\begin{document}
\maketitle

{
\setcounter{tocdepth}{2}
\tableofcontents
}
\subsection{Why use parallel
processing?}\label{why-use-parallel-processing}

The goal of this series of tutorials is to teach ecologists on how to
use parallel computing to perform null models. I thus assume that you
already know what a null model is. :)

Otherwise, there is an excellent book on the subject (Gotelli and
Graves, 1996) that is freely available to download
\href{https://www.uvm.edu/~ngotelli/nullmodelspage.html}{here}.

Why use parallel processing? The simple answer is time. If something
takes less time done through parallel processing, why not do it?
Computers nowadays have multi core processors with sufficient amount of
memory available to run parallel processing. Instead of waiting a long
time for a task to complete, one can divide the taks to run in multiple
cores and thus obtain outputs much faster.

Before deciding to parallelize your code, remember that there is a
trade-off between performance and simplicity. It takes some time to set
up the parallel cluster so if your code already runs fast it is not
worth it. If your code repeats a similar task over and over (e.g.,
bootstraping) then it is recommended to parallize to improve
performance. Hence, parallel computing is ideal for null models.

While there are many good tutorials on parallel computing in R out
there, I think it is better to provide a small introduction on how to
set up a parallel cluster and how to start coding in parallel before
jumping on the null models.

\subsubsection{R packages}\label{r-packages}

There are many packages to run parallel processing in R. Here are a few
examples:

\begin{itemize}
\tightlist
\item
  parallel
\item
  snow
\item
  doSNOW
\item
  doParallel
\item
  foreach
\end{itemize}

First install the \emph{doParallel} package
\texttt{install.packages("doParallel")}, which also installs both
\emph{parallel} and \emph{foreach} packages.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(doParallel)}
\end{Highlighting}
\end{Shaded}

Then set up a parallel cluster. Use the function \texttt{detectCores}
from the \emph{parallel} library to detect the number of cores in your
computer.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{detectCores}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

My computer has 4 cores. It is always recommended to leave one core free
for the computer to run other processes. For simplicity we will use 2
cores in this tutorial.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cl <-}\StringTok{ }\KeywordTok{makeCluster}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DataTypeTok{type =} \StringTok{'PSOCK'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This will create a \emph{Parallel Socket Cluster} (PSOCK). This type of
cluster only starts with the base packages and thus you need to export
additional variables, functions and packages to the cluster (see further
below) if you need them in your parallelized code.

You can also create a FORK cluster, which has better capabilities to
manage memory and already contain all the variables from the local
environment (i.e., no need for export) since all the cores share the
same memory. For this, use:
\texttt{cl\ \textless{}-\ makeCluster(2,\ type\ =\ \textquotesingle{}FORK\textquotesingle{})}
Note, however, that Windows does not support FORK clusters.

\subsubsection{foreach loops}\label{foreach-loops}

An intuitive way to perform a parallel process is to use the foreach
function which looks like a for loop but operates as a lapply()
function. As a first example we will perform the foreach function in
sequential mode by using \%do\%

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{foreach}\NormalTok{(}\DataTypeTok{i =} \DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{) }\OperatorTok{%do%}\StringTok{ }\NormalTok{\{}
  \KeywordTok{sqrt}\NormalTok{(i)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1.414214
## 
## [[3]]
## [1] 1.732051
## 
## [[4]]
## [1] 2
## 
## [[5]]
## [1] 2.236068
## 
## [[6]]
## [1] 2.44949
\end{verbatim}

In the example above we applied \texttt{sqrt()} on each ``i''. By
default, foreach returns the output in a list format. You can combine
the results in different ways. For instance if you want a vector output
you can add the argument ``.combine = c''.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{foreach}\NormalTok{(}\DataTypeTok{i =} \DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DataTypeTok{.combine =}\NormalTok{ c) }\OperatorTok{%do%}\StringTok{ }\NormalTok{\{}
  \KeywordTok{sqrt}\NormalTok{(i)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490
\end{verbatim}

If you want to use the foreach in parallel mode, you need to change
\%do\% to \%dopar\%. You also need to register the cluster. Here we use
the \emph{doParallel} package to do this.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{registerDoParallel}\NormalTok{(cl)}

\KeywordTok{foreach}\NormalTok{(}\DataTypeTok{i =} \DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DataTypeTok{.combine =}\NormalTok{ c) }\OperatorTok{%dopar%}\StringTok{ }\NormalTok{\{}
  \KeywordTok{sqrt}\NormalTok{(i)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490
\end{verbatim}

If you want to use a variable or object from the global environment in
the parallel cluster, you first need to export it either using the
\texttt{clusterExport} function, or using the .export argument in the
foreach function. Here I use the .export argument for exporting.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var1 <-}\DecValTok{10}
\NormalTok{var2 <-}\DecValTok{5}

\KeywordTok{foreach}\NormalTok{(}\DataTypeTok{i =} \DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DataTypeTok{.combine =}\NormalTok{ c, }\DataTypeTok{.export =} \KeywordTok{c}\NormalTok{(}\StringTok{"var1"}\NormalTok{,}\StringTok{"var2"}\NormalTok{)) }\OperatorTok{%dopar%}\StringTok{ }\NormalTok{\{}
\NormalTok{  (var1}\OperatorTok{+}\NormalTok{var2)}\OperatorTok{*}\NormalTok{i}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in e$fun(obj, substitute(ex), parent.frame(), e$data): already
## exporting variable(s): var1, var2
\end{verbatim}

\begin{verbatim}
## [1] 15 30 45 60 75 90
\end{verbatim}

If you need to use a particular function in the parallel cluster, you
also need to export it. Here I use the \texttt{clusterExport} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{is_even <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{%%}\StringTok{ }\DecValTok{2} \OperatorTok{==}\StringTok{ }\DecValTok{0}

\KeywordTok{clusterExport}\NormalTok{(cl, }\KeywordTok{c}\NormalTok{(}\StringTok{"var1"}\NormalTok{,}\StringTok{"var2"}\NormalTok{,}\StringTok{"is_even"}\NormalTok{))}

\KeywordTok{foreach}\NormalTok{(}\DataTypeTok{i =} \DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DataTypeTok{.combine =}\NormalTok{ c) }\OperatorTok{%dopar%}\StringTok{ }\NormalTok{\{}
  \KeywordTok{is_even}\NormalTok{((var1}\OperatorTok{+}\NormalTok{var2)}\OperatorTok{*}\NormalTok{i)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE
\end{verbatim}

If you need to use a function from a R package in the parallel cluster,
you need to export the package in the cluster as well. This can be done
by the argument ``.package'' in the foreach function or by using the
\texttt{ClusterEvalQ} function.

Let's use the ChickWeigth dataset which contains the variables weigth,
Time, Chick and Diet. We want to compute the growth of each chick (i.e.,
weigth \textasciitilde{} Time). We can use the dplyr package to subset
each chick from the dataset and then apply the \texttt{lm} function to
each one separately. Here we want the coefficients of the linear model
as a result and we will combine them by rows by using ``.combine =
rbind''.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(}\StringTok{"ChickWeight"}\NormalTok{)}
\KeywordTok{clusterEvalQ}\NormalTok{(cl,}\KeywordTok{library}\NormalTok{(}\StringTok{"dplyr"}\NormalTok{))}
\KeywordTok{clusterExport}\NormalTok{(cl,}\StringTok{"ChickWeight"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(}\KeywordTok{unique}\NormalTok{(ChickWeight}\OperatorTok{$}\NormalTok{Chick))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 50
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#there are 50 unique chicks in this data}

\NormalTok{Growth_coeff<-}\StringTok{ }\KeywordTok{foreach}\NormalTok{(}\DataTypeTok{i =} \DecValTok{1}\OperatorTok{:}\DecValTok{50}\NormalTok{, }\DataTypeTok{.combine =}\NormalTok{ rbind) }\OperatorTok{%dopar%}\StringTok{ }\NormalTok{\{}
\NormalTok{  temp_data <-}\StringTok{ }\NormalTok{ChickWeight }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(Chick }\OperatorTok{==}\StringTok{ }\NormalTok{i)}
\NormalTok{  Growth =}\StringTok{ }\KeywordTok{lm}\NormalTok{(weight }\OperatorTok{~}\StringTok{ }\NormalTok{Time, }\DataTypeTok{data =}\NormalTok{ temp_data)}
  \KeywordTok{coefficients}\NormalTok{(Growth)}
\NormalTok{\}}

\KeywordTok{head}\NormalTok{(Growth_coeff)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          (Intercept)      Time
## result.1    24.46544  7.987899
## result.2    24.72485  8.719861
## result.3    23.17955  8.487370
## result.4    32.86568  6.088640
## result.5    16.89563 10.055362
## result.6    44.12343  6.378006
\end{verbatim}

\subsubsection{Comparing execution time}\label{comparing-execution-time}

In the example above the \texttt{combine\ =\ .rbind} argument combined
\texttt{coefficients(Growth)} into the \texttt{Growth\_coeff} output.

Finally, let's see how much time do we save by using the parallelized
code. In this case we will repeat the above code 300 times and use the
\texttt{system.time} function to determine how much times it takes to
run.

First in sequential mode (\%do\%)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trials <-}\StringTok{ }\DecValTok{300}
\KeywordTok{system.time}\NormalTok{(\{}
\NormalTok{  Growth_coeff <-}\StringTok{ }\KeywordTok{foreach}\NormalTok{(}\KeywordTok{icount}\NormalTok{(trials), }\DataTypeTok{.combine=}\NormalTok{rbind, }\DataTypeTok{.packages =} \StringTok{"dplyr"}\NormalTok{) }\OperatorTok{%do%}\StringTok{ }\NormalTok{\{}
    
\NormalTok{    temp_coeff<-}\KeywordTok{matrix}\NormalTok{(}\KeywordTok{numeric}\NormalTok{(),}\DataTypeTok{ncol=}\DecValTok{2}\NormalTok{,}\DataTypeTok{nrow=}\DecValTok{50}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{50}\NormalTok{)\{}
\NormalTok{      temp_data <-}\StringTok{ }\NormalTok{ChickWeight }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(Chick }\OperatorTok{==}\StringTok{ }\NormalTok{i)}
\NormalTok{      Growth =}\StringTok{ }\KeywordTok{lm}\NormalTok{(weight }\OperatorTok{~}\StringTok{ }\NormalTok{Time, }\DataTypeTok{data =}\NormalTok{ temp_data)}
\NormalTok{      temp_coeff[i,]=}\KeywordTok{coefficients}\NormalTok{(Growth)}
\NormalTok{    \}}
\NormalTok{   temp_coeff}
\NormalTok{  \}}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    user  system elapsed 
##   38.62    0.28   41.03
\end{verbatim}

And now in parallel mode (\%dopar\%)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trials <-}\StringTok{ }\DecValTok{300}
\KeywordTok{system.time}\NormalTok{(\{}
\NormalTok{  Growth_coeff <-}\StringTok{ }\KeywordTok{foreach}\NormalTok{(}\KeywordTok{icount}\NormalTok{(trials), }\DataTypeTok{.combine=}\NormalTok{rbind, }\DataTypeTok{.packages =} \StringTok{"dplyr"}\NormalTok{) }\OperatorTok{%dopar%}\StringTok{ }\NormalTok{\{}
    
\NormalTok{    temp_coeff<-}\KeywordTok{matrix}\NormalTok{(}\KeywordTok{numeric}\NormalTok{(),}\DataTypeTok{ncol=}\DecValTok{2}\NormalTok{,}\DataTypeTok{nrow=}\DecValTok{50}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{50}\NormalTok{)\{}
\NormalTok{      temp_data <-}\StringTok{ }\NormalTok{ChickWeight }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(Chick }\OperatorTok{==}\StringTok{ }\NormalTok{i)}
\NormalTok{      Growth =}\StringTok{ }\KeywordTok{lm}\NormalTok{(weight }\OperatorTok{~}\StringTok{ }\NormalTok{Time, }\DataTypeTok{data =}\NormalTok{ temp_data)}
\NormalTok{      temp_coeff[i,]=}\KeywordTok{coefficients}\NormalTok{(Growth)}
\NormalTok{    \}}
\NormalTok{   temp_coeff}
\NormalTok{  \}}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    user  system elapsed 
##    0.22    0.06   25.78
\end{verbatim}

Make sure to \textbf{ALWAYS} close your cluster after finishing the
parallel processing

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stopCluster}\NormalTok{(cl)}
\end{Highlighting}
\end{Shaded}


\end{document}

---
title: "Introduction to Parallel Computing"
date: 13 November 2018
output: html_document
---



<style type="text/css">
body{ /* Normal  */
      font-size: 14px;
  }
h1 { /* Header 1 */
  font-size: 26px;
  color: DarkGreen;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkGreen;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>
<p>Why use parallel processing? The simple answer is time. If something takes less time done through parallel processing, why not do it? Computers nowadays have multi core processors with sufficient amount of memory available to run parallel processing. Instead of waiting a long time for a task to complete, one can divide the taks to run in multiple cores and thus obtain outputs much faster.</p>
<div id="r-packages" class="section level1">
<h1>R packages</h1>
<p>There are many packages to run parallel processing in R. Here are a few examples:</p>
<ul>
<li>parallel</li>
<li>snow</li>
<li>doSNOW</li>
<li>doParallel</li>
<li>foreach</li>
</ul>
<p>First install packages `r install.packages(“parallel”)’</p>
<p>Then set up a parallel cluster. Use the function “detectCores” from the <i>parallel<i/> library to detect the number of cores in your computer It is always recommended to leave one core for free for the computer to run its other processes. In this example, for simplicity, we will use 2 cores.</p>
<pre class="r"><code>library(doParallel)</code></pre>
<pre><code>## Loading required package: foreach</code></pre>
<pre><code>## Loading required package: iterators</code></pre>
<pre><code>## Loading required package: parallel</code></pre>
<pre class="r"><code>nc &lt;- detectCores()
cl &lt;- makeCluster(2)</code></pre>
<p>This will create a SOCK cluster, which can be done in all operating systems. If you want to create a FORK cluster (which has better capabilities to manage memory) “cl &lt;- makeCluster(nc-1, type =”FORK“)” note, however, that Windows does not support FORK clusters</p>
</div>
<div id="for-loops-and-foreach" class="section level1">
<h1>for loops and foreach</h1>
<p>An intuitive way to perform a parallel process is to use the foreach function which looks like a for loop but operates as a lapply() function. As a first example we will perform the foreach function in sequential by using %do%</p>
<pre class="r"><code>library(foreach)
foreach(i = 1:6) %do% {
  sqrt(i)
}</code></pre>
<pre><code>## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1.414214
## 
## [[3]]
## [1] 1.732051
## 
## [[4]]
## [1] 2
## 
## [[5]]
## [1] 2.236068
## 
## [[6]]
## [1] 2.44949</code></pre>
<p>In the example above we applied “sqrt” on each “i”. By default, foreach returns the output in a list format. You can combine the results in different ways. For instance if you want a vector output use the following you can add the argument “.combine = c”</p>
<pre class="r"><code>foreach(i = 1:6, .combine = c) %do% {
  sqrt(i)
}</code></pre>
<pre><code>## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490</code></pre>
<p>If you want to use the foreach in parallel mode, you need to change %do% to %dopar%. You also need to register the parallel backbend. Here we use the doParallel package to do this</p>
<pre class="r"><code>registerDoParallel(cl)

foreach(i = 1:6, .combine = c) %dopar% {
  sqrt(i)
}</code></pre>
<pre><code>## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490</code></pre>
<p>If you want to use a variable or object from the global environment in the parallel cluster, you first need to export it either using the clusterExport function, or using the .export argument in the foreach function</p>
<pre class="r"><code>var1 &lt;-10
var2 &lt;-5
clusterExport(cl, c(&quot;var1&quot;,&quot;var2&quot;))

foreach(i = 1:6, .combine = c, .export = c(&quot;var1&quot;,&quot;var2&quot;)) %dopar% {
  (var1+var2)*i
}</code></pre>
<pre><code>## Warning in e$fun(obj, substitute(ex), parent.frame(), e$data): already
## exporting variable(s): var1, var2</code></pre>
<pre><code>## [1] 15 30 45 60 75 90</code></pre>
<p>If you need to use a particular function in the parallel cluster, you also need to export it.</p>
<pre class="r"><code>is_even &lt;- function(x) x %% 2 == 0

clusterExport(cl, c(&quot;var1&quot;,&quot;var2&quot;,&quot;is_even&quot;))

foreach(i = 1:6, .combine = c) %dopar% {
  is_even((var1+var2)*i)
}</code></pre>
<pre><code>## [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE</code></pre>
<p>If you need to use a function from a R package in the parallel cluster, you need to export the package in the cluster. This can be done by the argument “.package” in the foreach function or by using the ClusterEvalQ function as follows.</p>
<p>Let’s use the ChickWeigth dataset which contains the variables weigth, Time, Chick and Time. We want to compute the growth of each chick (i.e., weigth ~ Time). We can use the dplyr package to apply the lm function to each chick in the dataset. If the output is a matrix and you want to combine the results by rows, you can use “.combine = rbind”.</p>
<pre class="r"><code>data(&quot;ChickWeight&quot;)
clusterEvalQ(cl,library(&quot;dplyr&quot;))</code></pre>
<pre><code>## [[1]]
## [1] &quot;dplyr&quot;     &quot;stats&quot;     &quot;graphics&quot;  &quot;grDevices&quot; &quot;utils&quot;     &quot;datasets&quot; 
## [7] &quot;methods&quot;   &quot;base&quot;     
## 
## [[2]]
## [1] &quot;dplyr&quot;     &quot;stats&quot;     &quot;graphics&quot;  &quot;grDevices&quot; &quot;utils&quot;     &quot;datasets&quot; 
## [7] &quot;methods&quot;   &quot;base&quot;</code></pre>
<pre class="r"><code>clusterExport(cl,&quot;ChickWeight&quot;)
numb_chicks &lt;- length(unique(ChickWeight$Chick))

new_data&lt;- foreach(i = 1:numb_chicks, .combine = rbind, .packages = &quot;dplyr&quot;) %dopar% {
  
  
  temp_data &lt;- ChickWeight %&gt;% filter(Chick == i) %&gt;% mutate(Growth = lm(weight ~ Time)$coeff[2])
  
}</code></pre>
<div id="including-plots" class="section level2">
<h2>Including Plots</h2>
<p>You can also embed plots, for example:</p>
<p><img src="/tutorial/tut_2_files/figure-html/pressure-1.png" width="672" /></p>
<p>Note that the <code>echo = FALSE</code> parameter was added to the code chunk to prevent printing of the R code that generated the plot.</p>
</div>
</div>
